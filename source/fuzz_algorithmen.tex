\chapter{Netzworkfuzzing}

Netzwerkfuzzing ist eine spezialisierte Form des Fuzzings, die sich auf die Anslyse und das Testen von Netzwerkprotokollen und -diensten konzentriert. Das Fuzzing kann ab Schicht 2 auf allen Schichten des OSI-Modells angewendet werden. 

Das \textbf{OSI-Modell} (Open Systems Interconnection Model) ist ein Referenzmodell, das die Kommunikation zwischen Computersystemen in sieben hierarchische Schichten unterteilt\footnote{Siehe \url{https://de.wikipedia.org/wiki/OSI-Modell}}. Diese Schichten reichen von der physischen Übertragung (Schicht 1) bis zur Anwendungsschicht (Schicht 7), die direkt mit Softwareanwendungen interagiert. Jede Schicht erfüllt spezifische Aufgaben und kommuniziert nur mit den direkt angrenzenden Schichten, wodurch eine modulare und standardisierte Netzwerkkommunikation ermöglicht wird.

Im folgenden betrachten wir die Grundkonzepte und Herausforderungen, ohne auf die spezifischen Herausforderungen einzelner Protokolle oder Schichten einzugehen.

\section{Herausforderungen im Netzwerkprotokoll-Fuzzing}

Die Autoren des Papers \cite{Jiang2024SurveyNetworkProtocolFuzzing}\textbf{Systematic Fuzzing and Testing of TLS Libraries
} identifizieren vier zentrale Charakteristika von Netzwerkprotokollen, die Fuzzing vor besondere Hürden stellen: 

\begin{itemize}
    \item \ref{sec:dep-network} Abhängigkeit von Netzwerk-Verbindungen.
    \item \ref{sec:dep-statefull} Zustandsbehaftetheit.
    \item \ref{sec:structured-input} Hoch strukturierte Eingaben.
    \item \ref{sec:non-uniformität} Nicht-Uniformität.
\end{itemize}

\subsection{Abhängigkeit von Netzwerk-Verbindungen}
\label{sec:dep-network}

Anders als beim Datei-Input Fuzzing, müssen hier Netzwerkpackete gefuzzt werden, die je nach Protokoll, in einer bestimmten zeitlichen, sequentiellen Abfolge bearbeitet werden müssen. Der Fuzzer muss also ein vollwertiges PAcket für das jeweilige Netzwerkprotokoll über eine Schnittstelle übertragen. Damit muss er nicht nur das Protokoll, sondern auch die Schnittstelle verstehen. Wenn beispielsweise ein HTTPs Server, oder ein VPN-Gateway gefuzzt werden soll, kann dies zu einer erhöhten Auslastung der Infrastruktur der Firma, oder ggf. zum Ausfall führen. Für den Whitebox Hacker ist diese Art des Fuzzings somit mit ggf. höheren Kosten als beim klassischem Desktop-CLI Fuzzing verbunden. Der Blackhat-Hacker wird unter umständen schneller erkannt und muss seinen Ursprung gut tarnen. 

Es lassen sich ggf. zeitliche und wirtschaftliche Kosten einsparen, wenn ein Testsystem eingerichtet wird, welches das Produktivsystem hinreichend emuliert. Beispielsweise kann auch einem Testrechner mittels OpenSSL ein TLS-Server mit derselben Version und Funktionalität eingerichtet werden.

\subsection{Zustandsbehaftetheit}
\label{sec:dep-statefull}

Netzwerkrptokolle sind üblicherweise Zustandsbehaftet. Dies kann dazu führen, dass derselbe Input, zu einem anderen Verhalten führt. Denn Zustandsbehaftet heißt, dass das Verhalten des Servers von seinem internen Zustand abhängig ist. Dies beeinflusst direkt das Design des Fuzzers. Der Input muss demzufolge so generiert werden, dass er Kette von Eingaben zum Protokoll darstellt. 

Die Grafik zeigt einen von den Autor*innen vorgeschlagenen Aufbau eines Fuzzers für zustandsbehaftete Protokolle. 
\(\mathbf{S_0}\), \(\mathbf{S_1}\) und \(\mathbf{S_2}\) repräsentieren Zustände des Protokolls. 
Sie werden aus den Eingaben \(\mathbf{C_{01}}\), \(\mathbf{C_{12}}\) und \(\mathbf{P}\) sequentiell generiert. 
Der Zustand \(\mathbf{S_2}\) ist der Endzustand des Protokolls. 
Ist dieser ein Fehlzustand, so wird dieser in eine Liste von Bugs übernommen.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{img/stateful-fuzzer.png}
        \caption[Zustandsbehaftetes Fuzzing]{\textit{Quelle:\cite{Jiang2024SurveyNetworkProtocolFuzzing}}}
    \label{fig:enter-label}
\end{figure}

\subsection{Hoch strukturierte Eingaben}
\label{sec:structured-input}

Netzwerkprotokolle sind hoch strukturiert. NAchrichten können in Big, oder Byte Felder mit strikter Grammatik partitioniert werden. Jedes dieser Partitionen hat eine klar definierte Range und Bedeutung. Diese Strukturen dürfen vom Fuzzer nicht verletzt werden. Randomisierte bitweise Eingabengenerierung, wie von AFL, kann daher zu einer vielzahl von Fehleingaben führen. 

\subsection{Nicht-Uniformität}
\label{sec:non-uniformität}

Es gibt eine vielzahl von Netzwerkprotokollen, welche sich meist in den zugrundeliegenden Zustandsübergängen und Grammatiken der Nachrichten unterscheiden. Daher ist eine Vielzahl an Netzwerkfuzzern auf ein Protokoll spezialisiert. 

\section{Allgemeines Vorgehensmodell}
\label{sec:allgemeines-vorgehensmodell}

Die Forscher des Artikels \cite{Jiang2024SurveyNetworkProtocolFuzzing}\textbf{A Survey of Network Protocol Fuzzing: Model, Techniques and Directions} schlagen ein vierstufiges Vorgehensmodell zur Lösung der genannten Herausforderungen vor: 
\begin{itemize}
  \item Protokollsyntax-Erfassung und Modelling
  \item Testfall-Erzeugung
  \item Testausführung und Monitoring
  \item Feedback-Informationserfassung und Nutzung
\end{itemize}

\subsection{Erste Stufe: Protokollsyntax-Erfassung}

In der ersten Stufe wird die Syntax der Nachrichten und der Zustandsübergänge (State-Machine) des Protokolls modelliert. 

Die Syntax der Nachrichten definiert hierbei eine über das Protokoll übertragene, valide Nachricht (Daten und Metadaten), ohne Kontext oder Zustand mit einzubeziehen. Es werden die Einteilung der Felder einer Nachricht, sowie deren Organisation und Abhängigkeiten betrachtet. Eine Nachricht kann Felder mit bestimmter Bedeutung und festgelegtem Datentyp haben, die in einer festgelgten Art miteinander in Beziehung stehen. 

Die State-Machine ist definiert die Zuständsübergange eines Netzwerkprotokolls. Die Zustandsübergange werden repräsentiert durch einen Automaten (Ref:Theoretische Informatik).

Dies bildet die Basis für alle weiteren Stufen im Vorgehensmodell. Wichtig ist, dass diese Stuffe zum Hauptfuzzing-Prozess parralelisiert werden kann, da die Ergebnisse dieses Prozesses dynamisch in den Hauptprozess übertragen werden können. 

\subsection{Zweite Stufe: Testfall-Erzeugung}

Diese Stufe fokussiert sich auf die Erzeugung von Testfällen. Basierend auf dem gewählten Modell und der gewählten Input-Generation-Strategie, werden in dieser Stufe die Testfälle generiert.

Die zu unterscheidenden Strategien wurden bereits in der Section \ref{sec:Grundlagen} eingeleitet.

\paragraph{Generationbasierte Strategien} definieren im Fall des Protokoll-Fuzzings zwei Arten von Modellen: Zustandsübergänge und Protokoll-Syntax. Frühere Fuzzer, sowie Spike \cite{Jiang2024SurveyNetworkProtocolFuzzing} stellten ein Interface in Form einer Konfigurationsdatei zur Verfügung, um diese Modelle zu spezifizieren. Diese Dateien enthalten eine Art Datenstruktur der Protokoll-Syntax und der Übergänge und bilden damit die erste Epoche der hier vorgestellten Strategie.

Dies setzt natürlich ein umfangreiches Wissen über das zu testende Protokoll voraus. Kleine Fehler des Modells führen zu einer gravierend kleineren Qualität des Testprozesses. Darüber hinaus fehlt diesen Modellen die Fähigkeit den Zustandsraum autonom, oder heuristisch zu erforschen, um eine optimale Testabdeckung zu erzielen. Stattdessen führen sie einen festen Zustandsautomaten aus, der auf kleine Veränderungen der Implementierung des Protokolls schlecht reagiert.\cite{Jiang2024SurveyNetworkProtocolFuzzing}

Eine Strategie aktueller Fuzzer, wie Peach oder PAVFuzz, gibt bestimmten Feldern eines Paketes eine unterschiedlich hohe, oder niedrige, Gewichtung in der Wichtigkeit. Sie kalkulieren dynamische mutationen auf diesen Gewichtungen für die Daten des Elements und speichern sie in relationalen Tabellen. Dadurch werden sogenannte \textbf{state sensitive Mutations} auf diesen Daten durchgeführt, um damit mit höherer Warscheinlichkeit Verwundbarkeiten zu entdecken. 

\paragraph{Mutation-Basierte Strategien} benötigen keine Spezifikation einer Syntax. Sie operieren auf Bit-Ebende mit Bitflip, Arithmetic, Havoc oder Splice Operationen, auf vordefinierten Seeds, um Testfälle zu generieren. 

Die Autoren des Artikels \cite{Jiang2024SurveyNetworkProtocolFuzzing} kritisieren, dass eine Manipulation auf Bit-Ebene ohne Syntax-Unterstützung häufig Testfälle generieren, die nicht der geforderten Grammatik des Protokolls entsprechen. Somit sind Coverage-Based Greybox Fuzzer, wie AFL und deren smarten derivate, wie AFLsmart, nicht auf Netzwerkprotokolle anzuwenden. Die Unterschiede zwischen klassischer Software und Protokollen sind zu groß. Diese Studie \cite{li2021protocol-fuzzing} hat untersucht, dass bis zu 90\% der generierten Testfälle invalide waren, wenn AFL auf Netzwerkprotokolle angewendet wurde. 

AFLnet wendet daher einen spezifischen Mechanismus an, um Testfälle für Netzwerkprotokolle zu generieren: Es kombiniert sequentiell alle Nachrichten vom Client während einer Interaktion in ein einziges seed. ASCII wird für die Trennung der Nachrichten im Seed verwendet. GLeichzeitig pflegt und updated es eine endliche state machine durch Extraktion der Response Codes.\cite{Jiang2024SurveyNetworkProtocolFuzzing} 

Dadurch wird es möglich, kontinuierlich neue Zustände in die State-Machine aufzunehmen, die im Fuzzing Prozess entdeckt werden. 

Dennoch hat ein mutationsbasierter Ansatz eine entscheidente Achillisverse: Die Qualität des Fuzzinghängt maßgebend vom Seed ab. Eine hoch-qualitatives Seed, welches auf die Protokoll-Syntax angepasst wurde, ist unerlässig für ein hoch-qualitatives Ergebnis. 

\paragraph{Fuzzer in the Middle}

Fuzzer in the Middle ist eine von dem Man in the Middle abgeleitete Strategie. Der Fuzzer steht hier zwischen Server und Client. Der Fuzzer fängt die Kommunikation ab und manipuliert diese beliebig. Dadurch kann der Fuzzer sowohl den Client, als auch den Server gleichzeitig fuzzen. Der Fuzzer muss hierbei nicht manipilieren. Vielmehr greift er gezielt den Zustand zwischen Client und Server an, für den Exploits gefunden werden sollen. 

Fuzzer in the Middle wird beispielsweise durch ProxyFuzz \hyperref{https://src.fedoraproject.org/rpms/proxyfuzz}, AutoFuzz \cite{Gorbunov2010autofuzz}, SEC-Fuzz\cite{tsankov2012secfuzz}, oder FITM\cite{maier2022fitm} implementiert. 

Nachteilig ist, dass diese Strategie die Komplexität der Implementierung und Ausführung des Fuzzings maßgeblich erhöht. Sofern die Kommunikation einem kryptographischem Verfahren zugrundeliegt, muss der Fuzzer über ein fundiertes Wissen über dieses verfügen.

\subsubsection{Anforderungen an den Testfall}

Die Erzeugung von Testfällen ist in Netzwerprotokollen vor zwei besonderen Herausforderungen gestellt: Zum einen muss ein Testfall der Protokollsyntax entsprechen. Zum anderen muss der generierte Testfall möglichst gut die komplexen Zustandsübergänge des Protokolls und seiner Implementierung abdecken. 

\subsection{Dritte Stufe: Testausführung und Monitor}

Die Testausführung bezeichnet den Prozess, bei dem das zu testende Programm (Program Under Test, PUT) die generierten Testfälle empfängt und verarbeitet. Der Monitor überwacht kontinuierlich das Verhalten des PUT während der Testausführung, um Anomalien, Abstürze oder andere unerwartete Verhaltensweisen zu identifizieren. Die meisten Protokoll-Fuzzer implementieren hierfür Mechanismen zur Detektion von Programmabstürzen in Kombination mit speicherbasierten Fehlererkennungsverfahren (z.\,B. AddressSanitizer, Valgrind).

Im Unterschied zu klassischen Fuzzern, nimmt die Testausführung eine große Rolle bei den Systemressourcen ein. Netzwerkprotokolle sind häufig zeitkritisch und erfordern eine präzise Steuerung der Netzwerkkommunikation. Daher muss die Testausführung effizient gestaltet sein, um eine hohe Testfall-Durchsatzrate zu gewährleisten.

Netzwerkprotkolle haben ebenso im Vergleich zum Lesen eines Files, oder der CLI, einen zeitlichen Overhead. Dieser ist darauf zurückzuführen, dass die Protokollsoftware zunächst Daten über das Netzwerkinterface senden und empfangen muss. Dies kann zu Latenzen führen, die den Fuzzing-Prozess verlangsamen. Im idealfall sind Fuzzer und PUT auf demselben System implementiert, um Netzwerk-Latenzen zu minimieren. Aber selbst dann muss der Fuzzer über die Loopback-Schnittstelle kommunizieren, was immer noch langsamer ist als der direkte Dateizugriff.

Darüber hinaus sind Multi-Threaded Server prinzipiell mit höheren Kosten, in Bezug auf Laufzeit, Speicher und Stromkosten, verbunden. 

In den folgenden Subsektionen werden Techniken vorgestellt, um die Effizienz der Testausführung und des Monitors erheblich zu verbessern.

\subsubsection{Snapshots für den Monitor}

Snapshots sind statische Kopien des internen Zustandes eines Betriebssystems, oder Prozesses im physischem Speicher und verschiedener Devices zu einem bestimmten Zeitpunkt.\cite{Jiang2024SurveyNetworkProtocolFuzzing}

Im Kontext des Netzwerkprotokoll-Fuzzings können Snapshots verwendet werden, um den Zustand des PUT zu einem bestimmten Zeitpunkt während der Testausführung zu erfassen. Dies ermöglicht es dem Monitor, den Zustand des PUT zu analysieren und potenzielle Fehlerquellen zu identifizieren und ggf. den Zustand wiederherzustellen, um den Fuzzing-Prozess fortzusetzen.

Diese Sektion könnte deutlich mehr Aufmerksamkeit erhalten. Um aber den Fokus nicht zu verlieren, wird gern auf die Originalquelle verwiesen. In dieser werden diverse weitere Quellen genannt, die einen tieferen Einblick in die Materie ermöglicht.

\subsubsection{Emulation von Netzwerken}

Einige Forschungen und Tools haben sich darauf konzentriert, kostenintensive Netzwerkinterfaces durch simulierte Netzwerke zu ersetzen. Die Forscher des Artikels \cite{Jiang2024SurveyNetworkProtocolFuzzing}[A Survey of Network Protocol Fuzzing: Model, Techniques and Directions] nennen hier beispielsweise \textbf{Nyx-net}, welches ein emuliertes Netzwerkinterface bereitstellt, das den Netzwerkverkehr zwischen dem Fuzzer und dem PUT simuliert. Dadurch können Netzwerkprotokolle getestet werden, ohne dass physische Netzwerkhardware erforderlich ist.

Dieses Thema ist allgemein sehr umfangreich und geht weit über den Rahmen in dieser Arbeit hinaus. Dennoch ist es wichtig zu wissen, dass es solche Ansätze gibt, um die Kosten und Komplexität des Netzwerkprotokoll-Fuzzings zu reduzieren.

\subsubsection{IO-Synchronisation}

\textbf{SFuzz} implementiert Synchronisationspunkte zur deterministischen Steuerung der Nachrichtenübertragung. Netzwerkprotokollsoftware operiert nach der Initialisierungsphase typischerweise in einer iterativen Event-Loop-Struktur. Jede Client-Eingabe induziert einen Verarbeitungszyklus bestehend aus: Nachrichtenempfang → Verarbeitung → Rücksprung in die Event-Loop. \textbf{SFuzz} platziert einen Synchronisationspunkt am Einstiegspunkt der Event-Loop, welcher deterministisch signalisiert, dass das PUT (Program Under Test) bereit zur Entgegennahme einer neuen Nachricht ist. Dadurch entfällt die Notwendigkeit heuristischer Verfahren (wie Timeout-basierte Mechanismen) zur Bestimmung des optimalen Sendezeitpunkts. Dies resultiert in einer signifikanten Steigerung der Fuzzing-Effizienz.

\subsection{Stufie vier: Feedback Informationserfassung und Nutzung}



\section{Zwei-Stufenmodell von TLS-Attacker}