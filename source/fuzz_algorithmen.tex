\chapter{Netzworkfuzzing}

\section{Herausforderungen und Besonderheiten}

Die Autoren des Papers \cite{Jiang2024SurveyNetworkProtocolFuzzing}\textbf{Systematic Fuzzing and Testing of TLS Libraries
} identifizieren vier zentrale Charakteristika von Netzwerkprotokollen, die Fuzzing vor besondere Hürden stellen: 

\begin{itemize}
    \item \ref{sec:dep-network} Abhängigkeit von Netzwerk-Verbindungen.
    \item \ref{sec:dep-statefull} Zustandsbehaftetheit.
    \item \ref{sec:structured-input} Hoch strukturierte Eingaben.
    \item \ref{sec:non-uniformität} Nicht-Uniformität.
\end{itemize}

\subsection{Abhängigkeit von Netzwerk-Verbindungen}
\label{sec:dep-network}

Anders als beim Datei-Input Fuzzing, müssen hier Netzwerkpackete gefuzzt werden, die je nach Protokoll, in einer bestimmten zeitlichen, sequentiellen Abfolge bearbeitet werden müssen. Der Fuzzer muss also ein vollwertiges PAcket für das jeweilige Netzwerkprotokoll über eine Schnittstelle übertragen. Damit muss er nicht nur das Protokoll, sondern auch die Schnittstelle verstehen. Wenn beispielsweise ein HTTPs Server, oder ein VPN-Gateway gefuzzt werden soll, kann dies zu einer erhöhten Auslastung der Infrastruktur der Firma, oder ggf. zum Ausfall führen. Für den Whitebox Hacker ist diese Art des Fuzzings somit mit ggf. höheren Kosten als beim klassischem Desktop-CLI Fuzzing verbunden. Der Blackhat-Hacker wird unter umständen schneller erkannt und muss seinen Ursprung gut tarnen. 

Es lassen sich ggf. zeitliche und wirtschaftliche Kosten einsparen, wenn ein Testsystem eingerichtet wird, welches das Produktivsystem hinreichend emuliert. Beispielsweise kann auch einem Testrechner mittels OpenSSL ein TLS-Server mit derselben Version und Funktionalität eingerichtet werden.

\subsection{Zustandsbehaftetheit}
\label{sec:dep-statefull}

Netzwerkrptokolle sind üblicherweise Zustandsbehaftet. Dies kann dazu führen, dass derselbe Input, zu einem anderen Verhalten führt. Denn Zustandsbehaftet heißt, dass das Verhalten des Servers von seinem internen Zustand abhängig ist. Dies beeinflusst direkt das Design des Fuzzers. Der Input muss demzufolge so generiert werden, dass er Kette von Eingaben zum Protokoll darstellt. 

Die Grafik zeigt einen von den Autor*innen vorgeschlagenen Aufbau eines Fuzzers für zustandsbehaftete Protokolle. 
\(\mathbf{S_0}\), \(\mathbf{S_1}\) und \(\mathbf{S_2}\) repräsentieren Zustände des Protokolls. 
Sie werden aus den Eingaben \(\mathbf{C_{01}}\), \(\mathbf{C_{12}}\) und \(\mathbf{P}\) sequentiell generiert. 
Der Zustand \(\mathbf{S_2}\) ist der Endzustand des Protokolls. 
Ist dieser ein Fehlzustand, so wird dieser in eine Liste von Bugs übernommen.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{img/stateful-fuzzer.png}
        \caption[Zustandsbehaftetes Fuzzing]{\textit{Quelle:\cite{Jiang2024SurveyNetworkProtocolFuzzing}}}
    \label{fig:enter-label}
\end{figure}

\subsection{Hoch strukturierte Eingaben}
\label{sec:structured-input}

Netzwerkprotokolle sind hoch strukturiert. NAchrichten können in Big, oder Byte Felder mit strikter Grammatik partitioniert werden. Jedes dieser Partitionen hat eine klar definierte Range und Bedeutung. Diese Strukturen dürfen vom Fuzzer nicht verletzt werden. Randomisierte bitweise Eingabengenerierung, wie von AFL, kann daher zu einer vielzahl von Fehleingaben führen. 

\subsection{Nicht-Uniformität}
\label{sec:non-uniformität}

Es gibt eine vielzahl von Netzwerkprotokollen, welche sich meist in den zugrundeliegenden Zustandsübergängen und Grammatiken der Nachrichten unterscheiden. Daher ist eine Vielzahl an Netzwerkfuzzern auf ein Protokoll spezialisiert. 

\section{Allgemeines Vorgehensmodell}
\label{sec:allgemeines-vorgehensmodell}

Die Forscher des Artikels \cite{Jiang2024SurveyNetworkProtocolFuzzing}\textbf{A Survey of Network Protocol Fuzzing: Model, Techniques and Directions} schlagen ein vierstufiges Vorgehensmodell zur Lösung der genannten Herausforderungen vor: 
\begin{itemize}
  \item Protokollsyntax-Erfassung und Modelling
  \item Testfall-Erzeugung
  \item Testausführung und Monitoring
  \item Feedback-Informationserfassung und Nutzung
\end{itemize}

\subsection{Erste Stufe: Protokollsyntax-Erfassung}

In der ersten Stufe wird die Syntax der Nachrichten und der Zustandsübergänge (State-Machine) des Protokolls modelliert. 

Die Syntax der Nachrichten definiert hierbei eine über das Protokoll übertragene, valide Nachricht (Daten und Metadaten), ohne Kontext oder Zustand mit einzubeziehen. Es werden die Einteilung der Felder einer Nachricht, sowie deren Organisation und Abhängigkeiten betrachtet. Eine Nachricht kann Felder mit bestimmter Bedeutung und festgelegtem Datentyp haben, die in einer festgelgten Art miteinander in Beziehung stehen. 

Die State-Machine ist definiert die Zuständsübergange eines Netzwerkprotokolls. Die Zustandsübergange werden repräsentiert durch einen Automaten (Ref:Theoretische Informatik).

Dies bildet die Basis für alle weiteren Stufen im Vorgehensmodell. Wichtig ist, dass diese Stuffe zum Hauptfuzzing-Prozess parralelisiert werden kann, da die Ergebnisse dieses Prozesses dynamisch in den Hauptprozess übertragen werden können. 

\subsection{Zweite Stufe: Testfall-Erzeugung}

Diese Stufe fokussiert sich auf die Erzeugung von Testfällen. Basierend auf dem gewählten Modell und der gewählten Input-Generation-Strategie, werden in dieser Stufe die Testfälle generiert.

Die zu unterscheidenden Strategien wurden bereits in der Section \ref{sec:Grundlagen} eingeleitet.

\subsubsection{Anforderungen an die Input-Generation-Strategie}

\paragraph{Generationbasierte Strategien} definieren im Fall des Protokoll-Fuzzings zwei Arten von Modellen: Zustandsübergänge und Protokoll-Syntax. Frühere Fuzzer, sowie Spike \cite{Jiang2024SurveyNetworkProtocolFuzzing} stellten ein Interface in Form einer Konfigurationsdatei zur Verfügung, um diese Modelle zu spezifizieren. Diese Dateien enthalten eine Art Datenstruktur der Protokoll-Syntax und der Übergänge und bilden damit die erste Epoche der hier vorgestellten Strategie.

Dies setzt natürlich ein umfangreiches Wissen über das zu testende Protokoll voraus. Kleine Fehler des Modells führen zu einer gravierend kleineren Qualität des Testprozesses. Darüber hinaus fehlt diesen Modellen die Fähigkeit den Zustandsraum autonom, oder heuristisch zu erforschen, um eine optimale Testabdeckung zu erzielen. Stattdessen führen sie einen festen Zustandsautomaten aus, der auf kleine Veränderungen der Implementierung des Protokolls schlecht reagiert.\cite{Jiang2024SurveyNetworkProtocolFuzzing}

Eine Strategie aktueller Fuzzer, wie Peach oder PAVFuzz, gibt bestimmten Feldern eines Paketes eine unterschiedlich hohe, oder niedrige, Gewichtung in der Wichtigkeit. Sie kalkulieren dynamische mutationen auf diesen Gewichtungen für die Daten des Elements und speichern sie in relationalen Tabellen. Dadurch werden sogenannte \textbf{state sensitive Mutations} auf diesen Daten durchgeführt, um damit mit höherer Warscheinlichkeit Verwundbarkeiten zu entdecken. 

\paragraph{Mutation-Basierte Strategien} benötigen keine Spezifikation einer Syntax. 

\subsubsection{Anforderungen an den Testfall}

Die Erzeugung von Testfällen ist in Netzwerprotokollen vor zwei besonderen Herausforderungen gestellt: Zum einen muss ein Testfall der Protokollsyntax entsprechen. Zum anderen muss der generierte Testfall möglichst gut die komplexen Zustandsübergänge des Protokolls und seiner Implementierung abdecken. 



